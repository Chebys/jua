# 抽象操作

## 执行模型
一个 Jua 程序由一个入口模块和若干依赖模块构成。（严格来说只要入口模块即可，因为模块均是动态加载的）

Jua程序的执行以[语句块](#语句块)为入口点，以[语句](语句.md)为基本单位。

进程有两种运行模式：单任务和多任务。

单任务模式中，进程会在入口模块执行完毕后退出。

多任务模式中，进程不会自动退出。退出方式取决于实现。可以使用 await/async 语法（todo）。

进程具有标准输出和标准错误。进程可以向标准输出写入任意值，向标准错误中写入Error对象。
* 是否以及如何将写入值转换为字符串由宿主程序决定。
* 宿主程序也可以选择忽略标准输出和标准错误，只要进程能按预期运行即可。

### 语句块
语句块是语句的序列。

函数体是特殊的语句块。函数体不能直接包含 continue 语句、break 语句。

模块是特殊的函数体。

jua 解释器可以将 jua 代码解析为模块。详见[语法](语法.md)。

执行一个 Jua 程序会产生一个贯穿始终的[作用域](值与类型.md#特殊对象)，称作全局作用域；其后执行入口模块。

执行一个语句块，需要提供父作用域，并生成一个新的作用域作为当前作用域。

执行一个模块，需要将全局作用域作为父作用域。

执行自定义函数的函数体，需要将函数定义所在作用域作为父作用域。

执行复合语句的语句块，需要将复合语句所在作用域作为父作用域。

默认情况下，语句块中的语句按顺序执行。
* 具体的执行规则见[语句](语句.md)。

语句块执行完毕后，对其作用域进行垃圾回收（todo）

## 函数调用

### 原生函数
原生函数的调用效果由宿主程序决定。
* 所有[内置函数](内置值.md#内置函数)均为原生函数。

### 自定义函数
自定义函数是在 jua 代码中定义的函数（参见[字面函数](表达式.md#字面函数)、[调用](表达式.md#调用)和[函数声明](语句.md#函数声明)）。由父作用域、参数列表（本质上是[灵活声明列表](表达式.md#灵活声明列表)）和函数体构成。父作用域即函数定义所在的作用域。

调用自定义函数时，首先创建父作用域的子作用域；在该作用域中，使用传入的值序列对参数列表进行[声明](表达式.md#灵活声明列表)，并执行函数体。将函数体的返回值作为函数返回值。若函数体无返回值，则返回 null。

## 属性操作
### 属性设置
属性设置只会设置对象自身属性。（无论属性是否存在，无论值的类型）
* 非对象不能进行属性设置
### 严格属性访问
若目标为对象，则访问对象自身属性。
否则，属性不存在。
### 属性访问
尝试严格属性访问。
若属性不存在，则进行继承属性访问。
### 继承属性访问
对目标 obj（未必为对象）进行继承属性访问：

若目标为作用域，则对其父作用域进行属性访问。

否则：

若 obj 没有原型，则属性不存在。

否则，设原型为 proto。

若 proto.isClass（严格属性访问）为 true，则对 obj.super （严格属性访问）进行属性访问。

否则，对 proto 进行属性访问。

* 简而言之，普通对象或值从原型继承属性，类从父类继承属性，作用域从父作用域继承属性

## 迭代
对迭代目标进行迭代，以产生一系列值。

若迭代目标具有 iter 元方法，则称该目标为迭代器，iter 元方法为迭代函数，并进行[迭代器迭代](#迭代器迭代)。

否则，若迭代目标为对象，则进行[属性迭代](#属性迭代)。

否则，迭代失败。
### 属性迭代
产生迭代目标（对象）的所有自身属性。
* 次序未定义，取决于实现。
### 迭代器迭代
伪代码描述：

	while(true)
		{done, value?, key?} = iter(target, key)
		if(done)
			break
		yield value
* 若 iter(target, key).done 为真，且未在迭代函数之外改变 target 状态，则该表达式应当总是为真（无论调用多少次）。否则，程序非良构。
* 如果迭代函数严格按照 key 来生成值（不改变迭代器状态），则该迭代器是可重复使用的。可以将其包装为一次性迭代器。
<!-- todo: 一定有键吗？键一定合法吗？ -->

## ToString
todo