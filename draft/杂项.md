杂项
====

## 术语
### 字节串
字节串和字符串是同义词。

### 类与实例
若一个对象的原型的 __class 属性（严格属性访问）为true，则称该对象为类。

若一个值的原型为类，则称该值为该类的实例。

* 类一定是对象，而实例不一定是对象。

若一个类 c1 具有 super 属性且属性值为类 c2，则称 c2 为 c1 的父类。（若属性值为普通对象？）。c1 为 c2 的子类。
规定子类的实例也是父类的实例。

若一个类是可调用的（通过 call 元方法），且返回值为类实例，则称该类为可构造类。

若一个类的 call 元方法为 Object.new，则称该类为标准可构造类。

* 标准可构造类的构造函数总是返回新的对象。（而不是已有的对象或其他类型的值）
* 内置类往往是可构造类，但不是标准可构造类。
* class 函数总是返回标准可构造类。
* 标准可构造类不应继承自非标准可构造类（无法得到预期的效果）。这意味着class函数无法产生非标准可构造类的子类。

### 纯净对象
除原型外没有其他内部属性的对象称作纯净对象。

使用字面对象产生的对象总是纯净对象。

类总是纯净对象。？

Jua 语言设计的一个原则：能使用原型规定的信息尽量不使用内部属性。

### 危险语句
以括号（`([{`） 或[字符串](词法.md#字面字符串)或负号（`-`）开头的（表达式）语句称作危险语句。

由于 jua 的表达式匹配是贪心的，且忽略空白符，导致危险语句很容易与上一个语句末尾的表达式结合在一起。（形成函数调用或抽取）

需要通过插入分号来避免结合。建议：要么所有简单语句后加分号，要么都不加，而是在危险语句前加分号。

### Readable 和 Writable
实现了类似 Buffer 的 read、write 方法的对象。

建议二进制数据处理相关的接口接收 Readable / Writable 为参数，相比仅接收 String / Buffer 具有更高的灵活性。

## 考虑
考虑让所有左值可声明。属性引用、抽取的声明过程与赋值过程一致。

好处之一是，可以更加方便地定义类的初始化函数：`init(self, self.name, self.age){}`



## 作用域问题
考虑以下代码（或看作 js / lua 的伪代码）：

	fun test(){
		print(x)
		let x = 2
	}
	let x = 1
	test()

在 js 中会报错，因为要输出的 x 在（函数）块作用域中，但尚未被声明，处于暂时性死区

在 lua 中会输出 nil，因为要输出的 x 不在任何局部变量的范围内（局部变量生效于声明语句之后），于是访问全局变量 x 得到 nil（或其他值）

在 jua 中会输出 1，即已经声明的外部的 x。这是我们（至少是我）想要的结果，但代价是使用动态作用域，降低了性能，并且使某些错误无法提前预知（因为无法在语法分析阶段确定变量的实际所在作用域，即使不使用 local 关键字）

## 模拟

	Object.new = fun(proto, *args){
		let obj = {}
		Object.setProto(obj, proto)
		if(type(proto.init)=='function')
			proto.init(obj, *args)
		return obj
	}
	let classProto = { //实际上等于 Object:getProto()
		__class = true,
		__call = Object.new
	}
	//或者，更普适的：
	let classProto = {
		__class = true,
		__call(proto, *args){
			let new = proto.new
			if(type(new)!='function')
				new = Object.new
			return new(proto, *args)
		}
	}
	fun class(proto){
		Object.setProto(proto, classProto)
		return proto
	}