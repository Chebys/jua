词法
====

一段 Jua 代码是一段字符序列，可以包含 ascii 字符和非 ascii 字符。其可以被解析为[函数体](抽象操作.md#语句块)。
* 非ascii字符只能出现在[字面字符串](#字面字符串)中。

一个 Jua 文件是一个文本文件，其内容为一段 Jua 代码。
* 不对文件的编码作规定，只要求实现能够识别其中的ascii字符。

分词器将 Jua 代码拆分为词元（token），并输入[解析器](语法.md)。

## 单词
    word ::= <由大小写英文字母、数字、下划线构成且不以数字开头的序列>

### 关键字
    keyword ::= 'as' | 'break' | 'continue' | 'case' | 'else' | 'false' | 'for' | 'fun' | 'if' | 'in' | 'is' | 'let' | 'local' | 'null' | 'return' | 'switch' | 'true' | 'while'

* 关键字的含义由所在语句决定。
* 所有关键字均可用于需要单词的结构（如属性名）。

## 空白符
ascii 中的空白符采用 C/C++ 标准，即 `'\f'` `'\n'` `'\r'` `'\t'` `'\v'` `' '`。

非ascii空白符由实现定义。

字面字符串外的空白符不会进入语法分析，仅用于分隔 token。

## 注释
单行注释以 `//` 开头，到换行符或代码结束为止。

注解是特殊的单行注释，以 `///` 开头。

多行注释：todo

除注解外的注释不会进入语法分析。

注解是否进行语法分析，及其含义，由实现定义。
* 官方实现中，注解被视作普通单行注释。

## 字面数字
    literal_num ::= <略>

## 字面字符串
    literal_str ::= sq_str | dq_str | bq_str
### 单引号字符串
    sq_str ::= "'" {sq_inner} "'"
    sq_inner ::= <[^\\\n'] | \\.>
* 上面使用了正则表达式。
### 双引号字符串
也称 字符串模板。

    dq_str ::= '"' {dq_inner} '"'
    dq_inner ::= <[^\\$"] | \\.> | '$' varname | '$' '{' expr '}'

* 上面使用了正则表达式。

这里用到了语法分析阶段的概念：varname 和 expr，但语法分析不考虑空白符，意味着语法结构可能带有任意数量的空白符。只能先打个补丁：这里 `varname` 两端不含空白符。

求值时，会对每个插值表达式求值，将结果转化为字符串（使用 [ToString](抽象操作.md#tostring) 操作），最后将所得字符串序列进行拼接。
### 反引号字符串
也称 原始字符串。

    bq_str ::= '`' {bq_inner} '`'
    bq_inner ::= <除'`'外的任意字符>
反引号字符串不会进行反转义。
* 如果需要在字符串中包含反引号，老老实实地用单引号/双引号字符串吧。
<!-- * 或者考虑带定界符的原始字符串：``(...)``	````(...)````	``border(...)border`` -->

### 字面字符串求值
字面字符串以一定规则转换为Jua字符串（字节串）。包括反转义（除非原始字符串）和编码两部分。

反转义：将字面字符串的字符序列转换为原始字符序列。采用常用规则，如 `\n` `\0` `\x` `\u`。

特别地，`\xXX` 直接表示一个字节，无需编码。`\u` 转义的字符必须采用utf8编码。

编码：将字符序列转换为字节串。不规定具体编码，只要求兼容 ascii 编码。
* 如果标准输出需要显示 Jua 字符串，建议使用一致的编码规则。
    * 建议都使用utf8编码。
* Jua的使用者可能需要关心：解释器能否区分代码中的ascii字符的非ascii字符？解释器如何将非ascii字符编码为字节串？输出端接收何种编码？
* 并不是说使用者必须关心编码规则。如果解释器同时承担了输出端的责任，通常不会出现编码问题。
* 如果使用官方实现，完全可以无脑使用utf8，并使用 unicode 库进行逐字符的处理（如果有需要），而无需关心具体编码规则。
* 相较而言，js中的字符串使用utf16编码，这意味着如果字符串中出现代理对，则使用者必须了解utf16编码规则，否则无法获取正确的字符或长度。

## 运算符
略

`..` range运算符

二元运算符重载优先使用左操作数的元方法
